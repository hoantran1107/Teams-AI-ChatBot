"""
A custom Python REPL implementation that safely executes Python code.

This module provides a secure and controlled environment for executing 
Python code generated by an LLM, replacing the dependency on langchain_experimental's
PythonREPLTool.
"""

import ast
import re
import sys
from contextlib import redirect_stdout
from io import StringIO
from typing import Any, Dict, Optional


def sanitize_input(query: str) -> str:
    """Sanitize input to the Python REPL.

    Remove whitespace, backtick & python (if it appears to be a code block)

    Args:
        query: The query to sanitize

    Returns:
        str: The sanitized query
    """
    # Removes `, whitespace & python from start
    query = re.sub(r"^(\s|`)*(?i:python)?\s*", "", query)
    # Removes whitespace & ` from end
    query = re.sub(r"(\s|`)*$", "", query)
    return query


class CustomPythonREPL:
    """A custom Python REPL implementation that safely executes Python code."""

    def __init__(self, globals_dict: Optional[Dict] = None, locals_dict: Optional[Dict] = None):
        """Initialize the REPL with optional global and local dictionaries.
        
        Args:
            globals_dict: Optional global namespace dictionary
            locals_dict: Optional local namespace dictionary
        """
        self._globals = globals_dict if globals_dict is not None else {}
        self._locals = locals_dict if locals_dict is not None else {}
        
        # Add built-in modules to globals
        self._globals.update({
            "pd": __import__("pandas"),
            "np": __import__("numpy"),
            "re": __import__("re"),
            "__builtins__": __builtins__
        })

    def run(self, code: str) -> str:
        """Execute Python code in a secure environment and return the output.
        
        Args:
            code: The Python code to execute
            
        Returns:
            str: The captured stdout output
        """
        # Prepare the output capture
        output_buffer = StringIO()
        
        try:
            # Use redirect_stdout to capture print statements
            with redirect_stdout(output_buffer):
                # Execute the code
                exec(code, self._globals, self._locals)
                
            return output_buffer.getvalue()
        except Exception as e:
            # Return the error as a string
            return f"{type(e).__name__}: {str(e)}"


class CustomPythonREPLTool:
    """A tool for running Python code safely, similar to PythonREPLTool."""

    def __init__(self, globals_dict: Optional[Dict] = None, locals_dict: Optional[Dict] = None):
        """Initialize the tool with optional global and local dictionaries.
        
        Args:
            globals_dict: Optional global namespace dictionary
            locals_dict: Optional local namespace dictionary
        """
        self.python_repl = CustomPythonREPL(globals_dict, locals_dict)
        self.sanitize_input = True

    def run(self, query: str) -> str:
        """Execute the Python code.
        
        Args:
            query: The Python code to execute
            
        Returns:
            str: The output of the executed code
        """
        if self.sanitize_input:
            query = sanitize_input(query)
        return self.python_repl.run(query)


class CustomPythonAstREPLTool:
    """A more advanced Python REPL tool that uses AST for better control."""

    def __init__(self, globals_dict: Optional[Dict] = None, locals_dict: Optional[Dict] = None):
        """Initialize the tool with optional global and local dictionaries.
        
        Args:
            globals_dict: Optional global namespace dictionary
            locals_dict: Optional local namespace dictionary
        """
        # Ensure Python 3.9+ for AST features
        if sys.version_info < (3, 9):
            raise ValueError(
                "This tool relies on Python 3.9 or higher "
                "(as it uses new functionality in the `ast` module, "
                f"you have Python version: {sys.version}"
            )
            
        self.globals = globals_dict if globals_dict is not None else {}
        self.locals = locals_dict if locals_dict is not None else {}
        self.sanitize_input = True

    def run(self, query: str) -> str:
        """Execute Python code using AST for better control and return values.
        
        Args:
            query: The Python code to execute
            
        Returns:
            str: The output or return value of the executed code
        """
        try:
            if self.sanitize_input:
                query = sanitize_input(query)
                
            tree = ast.parse(query)
            if not tree.body:
                return ""
                
            # Execute all statements except the last one
            module = ast.Module(tree.body[:-1], type_ignores=[])
            exec(ast.unparse(module), self.globals, self.locals)
            
            # Handle the last statement separately to capture its return value
            module_end = ast.Module(tree.body[-1:], type_ignores=[])
            module_end_str = ast.unparse(module_end)
            
            # Capture output and try to evaluate for return value
            io_buffer = StringIO()
            try:
                with redirect_stdout(io_buffer):
                    ret = eval(module_end_str, self.globals, self.locals)
                    if ret is None:
                        return io_buffer.getvalue()
                    else:
                        return str(ret)
            except Exception:
                # If evaluation fails, execute as statement
                with redirect_stdout(io_buffer):
                    exec(module_end_str, self.globals, self.locals)
                return io_buffer.getvalue()
                
        except Exception as e:
            return f"{type(e).__name__}: {str(e)}"
